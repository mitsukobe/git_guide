Step one: Set configuration options
- git config -- list : summarizes configuration options
- user.name
- user.email
- core.editor 

user.email=dimitra.bernidaki@ln2db.com
user.name=dimitra bernidaki
core.editor='C:/Program Files (x86)/Notepad++/notepad++.exe' -multiInst -nosession

Step two: initialize repository
- cd ...\mygitrepository_whateva
- git init

Step three: add files to staging area
-	git status
-	git add 

It turns out that Git stages a file exactly as it is when you run the git add command. 
If you commit now, the version of CONTRIBUTING.md as it was when you last ran the git 
add command is how it will go into the commit, not the version of the file as it looks 
in your working directory when you run git commit. If you modify a file after you run 
git add, you have to run git add again to stage the latest version of the file.

Step optional: git ignore
- https://github.com/github/gitignore

Step four: comparing
- git diff: That command compares what is in your working directory with what is in 
your staging area. The result tells you the changes you’ve made that you haven’t yet 
staged.

- git diff --staged: If you want to see what you’ve staged that will go into your next 
commit.

- git difftool: it uses vim and grafical file comparison

Step five: commit
- git commit: opens the default editor for the message of the commit
- git commit -m '' : the message can be written in the ''
- git commit -a: Adding the -a option to the git commit command makes Git automatically 
stage every file that is already tracked before doing the commit, letting you skip the 
git add part.

Now you’ve created your first commit! You can see that the commit has given you some 
output about itself: which branch you committed to (master), what SHA-1 checksum the
commit has (463dc4f), how many files were changed, and statistics about lines added 
and removed in the commit.

